# © Dan Neidle and Tax Policy Associates 2026
import re
from typing import Any

from ai_search.citations import extract_structured_citations
from ai_search.config import (
    MODEL_NAME,
    SOURCE_DOC_ID_RE,
    VERIFICATION_MAX_DOC_CHARS,
    VERIFICATION_MAX_TOTAL_SOURCE_CHARS,
)
from ai_search.es_client import fetch_document_content_for_source
from ai_search.tooling import bates_from_text, types

VERIFIER_PROMPT = VERIFIER_PROMPT = """# Role and Mandate
You are the **Compliance Auditor** for a forensic investigation system.
Your goal is to review a "Draft Answer" against a set of "Source Documents" to ensure absolute factual accuracy.
You do not rewrite the answer. You strictly **annotate** and **certify** it.

# Input Data
You will be provided with:
1.  **Draft Answer:** The text generated by an investigator.
2.  **Source Context:** The actual text of the documents cited in the draft.

# The "Four Outcomes" Protocol
You must classify the Draft Answer into one of four states and edit the text accordingly.

### 1. [VERIFIED]
**Condition:** Every claim is supported by the text. Every quote is accurate.
**Action:** Return the text exactly as is.

### 2. [MINOR_REDACTION]
**Condition:** The core facts are true, but the draft includes unsupported adjectives, minor details, or emotional language not found in the text.
**Action:** Use markdown strikethrough (`~~text~~`) to remove the unsupported words.

### 3. [DISPUTED_CONTEXT]
**Condition:** The facts are cited, but the conclusion drawn is an *inference* or *opinion* not explicitly stated in the text.
**Action:** Do not delete. Insert a bolded note immediately after the sentence.
* *Format:* `...end of sentence. **[Auditor Note: Document EFTA123 confirms the meeting, but does not state the purpose.]**`

### 4. [FAILED]
**Condition:** The draft invents facts, cites documents that do not exist, or claims the opposite of what the document says.
**Action:** Remove the entire hallucinated section and replace it with a placeholder.
* *Format:* `**[SECTION REMOVED: Claim regarding 'Subject X' is not supported by the cited Evidence.]**`

# Operational Rules (Strict adherence required)

1.  **Check Quotes:** Verify that every text inside quotation marks `""` actually appears in the Source Context. If a quote is fake, mark the section as **[FAILED]**.

2.  **Check Citations:** If the draft cites `[EFTA123]` or `{source_doc_id: EFTA123}`, verify that `EFTA123` is in your Source Context.

3.  **The "Summary" Exception (CRITICAL):**
    * The **Executive Summary** and **Conclusion** sections are summaries. They often do not have inline citations.
    * **DO NOT** delete claims in these sections solely because they lack a citation tag.
    * **INSTEAD**, check if the claim is supported by the cited facts in the "Evidence Found" section.
    * If the Summary says "He met Epstein," and the Evidence section cites a document confirming that meeting, the Summary is **VERIFIED**.
    * Only remove Summary claims that have *no support anywhere* in the Draft Answer.

4.  **The "Header" Exception:**
    * Do not delete introductory sentences or headers (e.g., "Fact 1: The Email") solely because they lack a citation, *provided* that the text immediately following it provides the source and quote.

5.  **Material Claims:** For the "Evidence Found" section, strict citation is required. If a specific quote or fact in the evidence body lacks a source, remove it.

# Final Output Format
Return the processed text followed immediately by a status block.

[Processed Text Body...]

---
**Verification Report**
**Status:** **Verified / Minor Redaction / Disputed Context / Failed**

Always append a final one-line signoff after the report in this exact format:
Comments from Verification Agent: [one-sentence conclusion]
"""

STATUS_RE = re.compile(r"(?im)^\s*(?:\*\*)?status(?:\*\*)?\s*:\s*(.+?)\s*$")
SIGNOFF_RE = re.compile(r"(?im)^Comments from Verification Agent:\s*\[[^\]]+\]\s*$")
LEGACY_SIGNOFF_RE = re.compile(r"(?im)^Verification Agent:\s*\[[^\]]+\]\s*$")
AUDITOR_SIGNATURE_RE = re.compile(r"(?im)^\s*(?:\*\*)?auditor_signature(?:\*\*)?\s*:\s*.*(?:\n|$)")
MONTH_NAME_RE = re.compile(
    r"(?i)\b(?:jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|"
    r"jul(?:y)?|aug(?:ust)?|sep(?:tember)?|oct(?:ober)?|nov(?:ember)?|dec(?:ember)?)\b"
)
DATE_RE = re.compile(r"\b\d{1,2}[/-]\d{1,2}[/-]\d{2,4}\b")
YEAR_RE = re.compile(r"\b(?:19|20)\d{2}\b")
MONEY_RE = re.compile(r"(?:[$£€]\s*\d[\d,]*(?:\.\d+)?)|(?:\b\d{1,3}(?:,\d{3})+(?:\.\d+)?\b)")
CITATION_MARKER_RE = re.compile(
    r"(?i)(?:\bEFTA\d{8}\b|https?://\S+/f/[0-9a-f]{32}|\b[0-9a-f]{32}\b|\"source_doc_id\"\s*:\s*\"(?:[0-9a-f]{32}|EFTA\d{8})\"|\[citation:\s*)"
)
SENTENCE_CHUNK_RE = re.compile(r"[^\n.!?]+(?:[.!?](?=\s|$)|$)")
SIGNIFICANT_KEYWORDS = (
    "epstein",
    "maxwell",
    "meeting",
    "met ",
    "email",
    "called",
    "visited",
    "flight",
    "paid",
    "payment",
    "mandelson",
    "bannon",
    "girl",
    "massage",
    "transfer",
    "wire",
    "invoice",
    "arranged",
    "introduced",
    "alleg",
    "assault",
    "abuse",
    "traffick",
    "charged",
    "convict",
    "prosecut",
    "evidence",
    "record",
    "document",
    "confirms",
    "shows",
    "states",
)

STATUS_DISPLAY: dict[str, str] = {
    "VERIFIED": "Verified",
    "MINOR_REDACTION": "Minor Redaction",
    "DISPUTED_CONTEXT": "Disputed Context",
    "FAILED": "Failed",
}


def _normalize_status_key(raw_status: str) -> str:
    cleaned = str(raw_status or "").strip()
    cleaned = re.sub(r"[\[\]\*`]", "", cleaned)
    cleaned = re.sub(r"\s+", "_", cleaned)
    cleaned = cleaned.strip("_").upper()
    if cleaned in STATUS_DISPLAY:
        return cleaned
    return "FAILED"


def _display_status(status_key: str) -> str:
    return STATUS_DISPLAY.get(status_key, STATUS_DISPLAY["FAILED"])


def _contains_citation_marker(text: str) -> bool:
    return CITATION_MARKER_RE.search(str(text or "")) is not None


def _is_significant_claim(text: str) -> bool:
    claim = " ".join(str(text or "").split())
    if not claim:
        return False

    lower = claim.lower()
    if lower.startswith(("status:", "verification report", "comments from verification agent:")):
        return False

    # Trivial background facts should not be rejected for missing citations.
    if re.fullmatch(
        r"[A-Z][A-Za-z .'-]{1,80}\s+is\s+(?:in|a|an|the)\s+[A-Z][A-Za-z .'-]{1,80}[.!?]?",
        claim,
    ):
        return False

    if any(keyword in lower for keyword in SIGNIFICANT_KEYWORDS):
        return True
    if MONTH_NAME_RE.search(claim) or DATE_RE.search(claim):
        return True
    if MONEY_RE.search(claim):
        return True
    if YEAR_RE.search(claim) and re.search(
        r"(?i)\b(?:met|paid|emailed|called|visited|flew|arranged|alleged|charged|convicted|prosecuted)\b",
        claim,
    ):
        return True

    return False


def _find_uncited_significant_claims(text: str, max_claims: int = 8) -> list[tuple[int, int, str]]:
    findings: list[tuple[int, int, str]] = []
    body = str(text or "")
    for match in SENTENCE_CHUNK_RE.finditer(body):
        raw_sentence = match.group(0).strip()
        if not raw_sentence:
            continue

        sentence = re.sub(r"^[\-\*\d\.\)\s]+", "", raw_sentence).strip()
        if not sentence:
            continue
        if sentence.startswith(("```", "---", "#")):
            continue
        if not _is_significant_claim(sentence):
            continue

        start, end = match.span()
        context_start = max(0, start - 40)
        context_end = min(len(body), end + 280)
        context = body[context_start:context_end]
        if _contains_citation_marker(context):
            continue

        preview = " ".join(sentence.split())
        if len(preview) > 180:
            preview = preview[:177].rstrip() + "..."
        findings.append((start, end, preview))
        if len(findings) >= max_claims:
            break

    return findings


def _reject_uncited_significant_claims(text: str) -> tuple[str, list[str]]:
    claims = _find_uncited_significant_claims(text)
    if not claims:
        return text, []

    redacted = str(text or "")
    previews: list[str] = []
    replacement = "**[SECTION REMOVED: Significant claim lacks required citation/source ID.]**"
    for start, end, preview in reversed(claims):
        redacted = redacted[:start] + replacement + redacted[end:]
        previews.append(preview)

    previews.reverse()
    return redacted, previews


def _ordered_source_ids(draft_text: str) -> list[str]:
    source_ids: list[str] = []
    seen: set[str] = set()

    for citation in extract_structured_citations(draft_text):
        source_doc_id = str(citation.get("source_doc_id", "")).strip()
        if source_doc_id and source_doc_id not in seen:
            seen.add(source_doc_id)
            source_ids.append(source_doc_id)

    for bates in bates_from_text(draft_text):
        bates_up = str(bates).strip().upper()
        if bates_up and bates_up not in seen:
            seen.add(bates_up)
            source_ids.append(bates_up)

    return source_ids


def _build_source_context(draft_text: str) -> str:
    source_ids = _ordered_source_ids(draft_text)
    if not source_ids:
        return "[NO_SOURCE_CONTEXT] No cited source documents were detected in the draft answer."

    parts: list[str] = []
    used_chars = 0
    for source_id in source_ids:
        source_id_norm = source_id.lower() if SOURCE_DOC_ID_RE.fullmatch(source_id.lower()) else source_id.upper()
        content = fetch_document_content_for_source(source_id_norm).strip()
        if not content:
            parts.append(f"[SOURCE {source_id_norm}] [MISSING OR UNREADABLE]")
            continue

        truncated = False
        if len(content) > VERIFICATION_MAX_DOC_CHARS:
            content = content[:VERIFICATION_MAX_DOC_CHARS]
            truncated = True

        if used_chars + len(content) > VERIFICATION_MAX_TOTAL_SOURCE_CHARS:
            remaining = max(0, VERIFICATION_MAX_TOTAL_SOURCE_CHARS - used_chars)
            if remaining == 0:
                parts.append("[SOURCE_CONTEXT_TRUNCATED] Context budget reached.")
                break
            content = content[:remaining]
            truncated = True

        used_chars += len(content)
        suffix = "\n[TRUNCATED]" if truncated else ""
        parts.append(f"[SOURCE {source_id_norm}]\n{content}{suffix}")

    return "\n\n".join(parts)


def _extract_status(text: str) -> str:
    match = STATUS_RE.search(text or "")
    if not match:
        return "FAILED"
    return _normalize_status_key(match.group(1))


def _normalize_verification_report_block(text: str) -> str:
    cleaned = str(text or "")
    cleaned = AUDITOR_SIGNATURE_RE.sub("", cleaned)
    cleaned = LEGACY_SIGNOFF_RE.sub(
        lambda m: m.group(0).replace("Verification Agent:", "Comments from Verification Agent:"),
        cleaned,
    )

    status_key = _extract_status(cleaned)
    status_display = _display_status(status_key)
    status_line = f"**Status:** **{status_display}**"

    if STATUS_RE.search(cleaned):
        cleaned = STATUS_RE.sub(status_line, cleaned, count=1)
    elif re.search(r"(?im)^\s*\*\*verification report\*\*\s*$", cleaned):
        cleaned = re.sub(
            r"(?im)^(\s*\*\*verification report\*\*\s*)$",
            rf"\1\n{status_line}",
            cleaned,
            count=1,
        )
    else:
        cleaned = f"{cleaned.rstrip()}\n\n---\n**Verification Report**\n{status_line}"

    cleaned = re.sub(r"\n{3,}", "\n\n", cleaned)
    return cleaned.rstrip()


def _ensure_signoff(text: str) -> str:
    cleaned = _normalize_verification_report_block(text)
    if SIGNOFF_RE.search(cleaned):
        return cleaned

    status = _extract_status(cleaned)
    conclusions = {
        "VERIFIED": "All reviewed claims are supported by the provided source context.",
        "MINOR_REDACTION": "Core claims stand, with unsupported phrasing redacted.",
        "DISPUTED_CONTEXT": "Evidence is present, but some interpretations required auditor notes.",
        "FAILED": "Material claims failed verification and were removed or flagged.",
    }
    conclusion = conclusions.get(status, conclusions["FAILED"])
    return f"{cleaned}\n\nComments from Verification Agent: [{conclusion}]"


def run_verification_agent(client: Any, draft_text: str) -> str:
    if not draft_text.strip():
        return draft_text

    redacted_text, uncited_claims = _reject_uncited_significant_claims(draft_text)
    if uncited_claims:
        bullets = "\n".join(f"- {claim}" for claim in uncited_claims)
        failure = (
            f"{redacted_text.rstrip()}\n\n"
            "**[SECTION REMOVED: Significant uncited claims were rejected.]**\n"
            "Rejected claims:\n"
            f"{bullets}\n\n---\n"
            "**Verification Report**\n"
            "**Status:** **Failed**"
        )
        return _ensure_signoff(failure)

    if client is None or types is None:
        fallback = (
            f"{draft_text.rstrip()}\n\n---\n"
            "**Verification Report**\n"
            "**Status:** **Failed**"
        )
        return _ensure_signoff(fallback)

    source_context = _build_source_context(draft_text)
    payload = (
        "Draft Answer:\n"
        f"{draft_text}\n\n"
        "Source Context:\n"
        f"{source_context}"
    )

    config = types.GenerateContentConfig(
        system_instruction=VERIFIER_PROMPT,
        temperature=0,
    )
    response = client.models.generate_content(
        model=MODEL_NAME,
        contents=payload,
        config=config,
    )
    verified_text = (getattr(response, "text", None) or "").strip()
    if not verified_text:
        verified_text = (
            f"{draft_text.rstrip()}\n\n---\n"
            "**Verification Report**\n"
            "**Status:** **Failed**"
        )
    else:
        verified_redacted, verified_uncited_claims = _reject_uncited_significant_claims(verified_text)
        if verified_uncited_claims:
            bullets = "\n".join(f"- {claim}" for claim in verified_uncited_claims)
            verified_text = (
                f"{verified_redacted.rstrip()}\n\n"
                "**[SECTION REMOVED: Significant uncited claims were rejected.]**\n"
                "Rejected claims:\n"
                f"{bullets}\n\n---\n"
                "**Verification Report**\n"
                "**Status:** **Failed**"
            )
    return _ensure_signoff(verified_text)
